#pragma once

#include <Arduino.h>
#include <Stream.h>

#include <iostream>
#include <chrono>
#include <stdio.h>
#include <pb_encode.h>
#include <pb_decode.h>
#include "c110p_serial.pb.h" // Generated by nanopb

#include "RingBuffer.h"
#include "CRC8.h"

#define BUFFER_DATA_MAX_SIZE 128
#define BUFFER_MESSAGE_MAX_SIZE 256

class ProtoFrame
{
public:
    C110PRegion m_regionId;
    Stream* m_stream;
    RingBuffer<C110PCommand> m_sentMessageBuffer;     // Ring buffer for storing SENT messages
    RingBuffer<C110PCommand> m_receivedMessageBuffer; // Ring buffer for storing RECEIVED messages
    uint32_t m_messageTimeout;               // Timeout for message acknowledgment
    uint32_t m_maxRetries;               // Maximum number of retries for unacknowledged messages
    struct MessageInfo {
        uint32_t lastProcessedTimestamp;
        uint8_t retryCount;
    };

    std::unordered_map<uint32_t, MessageInfo> m_messageInfoMap; // message_id -> info

    static constexpr int8_t START_BYTE = 0xAA;
    static constexpr size_t MAX_SIZE = 128;
    
    uint8_t m_inputBuffer[BUFFER_MESSAGE_MAX_SIZE];
    size_t m_inputIndex = 0;
    size_t m_inputLength = 0;
    uint8_t m_inputCrc = 0;

    std::function<uint64_t()> m_timestampProvider = nullptr; // Timestamp provider function
    std::function<void(const C110PCommand_data_led_MSGTYPE&)> m_LedCallback = nullptr;
    std::function<void(const C110PCommand_data_sound_MSGTYPE&)> m_SoundCallback = nullptr;
    std::function<void(const C110PCommand_data_move_MSGTYPE&)> m_MoveCallback = nullptr;


    explicit ProtoFrame(Stream* stream, C110PRegion identifier = C110PRegion_REGION_UNSPECIFIED, uint32_t timeout = 1000, uint32_t maxRetries = 3)
        : 
        m_regionId(identifier),
        m_stream(stream),
        m_messageTimeout(timeout), 
        m_maxRetries(maxRetries),
        m_timestampProvider([]() -> uint64_t { 
            return static_cast<uint64_t>(
                std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()
                ).count()
            ); 
        }),
        m_LedCallback([](const C110PCommand_data_led_MSGTYPE&) { return; }),
        m_SoundCallback([](const C110PCommand_data_sound_MSGTYPE&) { return; }),
        m_MoveCallback([](const C110PCommand_data_move_MSGTYPE&) { return; })
    {
        
    }

    void reset()
    {
        m_sentMessageBuffer.reset();
        m_receivedMessageBuffer.reset();
        m_messageInfoMap.clear();
        m_inputIndex = 0;
        m_inputLength = 0;
        m_inputCrc = 0;
    }

    void setTimestampProvider(uint64_t (*provider)()) {
        m_timestampProvider = provider;
    }

    virtual uint32_t getSafeTimestamp() const {
        // Safely cast uint64_t timestamp to uint32_t by taking the lower 32 bits
        return static_cast<uint32_t>(m_timestampProvider() & 0xFFFFFFFF);
    }
    
    void setLedCallback(void (*cb)(const C110PCommand_data_led_MSGTYPE&)) {
        m_LedCallback = cb;
    }

    void setSoundCallback(void (*cb)(const C110PCommand_data_sound_MSGTYPE&)) {
        m_SoundCallback = cb;
    }

    void setMoveCallback(void (*cb)(const C110PCommand_data_move_MSGTYPE&)) {
        m_MoveCallback = cb;
    }

    virtual bool send(const C110PCommand& message)
    {
        m_sentMessageBuffer.add(message);
        return false;
    }

    virtual bool receive(C110PCommand& message)
    {
        m_receivedMessageBuffer.add(message);
        return false;
    }

    bool readFrame();

    virtual uint32_t getSentMessageBufferSize() const
    {
        return m_sentMessageBuffer.size();
    }
    
    virtual uint32_t getReceivedMessageBufferSize() const
    {
        return m_receivedMessageBuffer.size();
    }

    uint32_t getUnacknowledgedMessagesSize() const
    {
        return m_messageInfoMap.size();
    }

    uint32_t getUnacknowledgedMessage(uint32_t timestamp) const
    {
        auto it = m_messageInfoMap.find(timestamp);
        if (it != m_messageInfoMap.end())
        {
            return timestamp;
        }
        return 0;
    }
    
    C110PCommand getLastSentMessage()
    {
        return m_sentMessageBuffer.getCurrentValue();
    }

    C110PCommand getLastReceivedMessage()
    {
        return m_receivedMessageBuffer.getCurrentValue();
    }

    virtual void handleAck(uint32_t timestamp);

    virtual void sendAck(uint32_t timestamp);

    virtual void sendNack(uint32_t timestamp, const char* reason = "Unknown");

    virtual void handleNack(uint32_t timestamp);

    void retryMessages();

    virtual void resendMessage(C110PCommand& message);

    void receiveMessage(const uint8_t* rawMessage, size_t length);

    virtual void processCallback(const C110PCommand& message);

};
